<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
      PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
   "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!-- 회원 기능과 관련된 SQL문이 있는 member.xml 파일을 작성합니다.
          먼저, 다른 파일의 SQL문과 구별하기 위해 네임스페이스(namespace)를
     mapper.member로 지정하고, SQL문을 실행한 후 반환되는
         회원 정보 레코드를 저장하기 위한 resultMap을 지정합니다.
          각 레코드는 한 개의 MemberVO 객체를 생성한 후 지정한 속성에 따라
          레코드의 칼럼 값을 저장합니다. select 태그의 id 속성은
     MemberDAO에서 SQL문을 구분해서 호출하는 용도로 사용되며,
         반환되는 레코드를 id가 memResult인 resultMap에 저장합니다.-->

<!-- member.xml의 네임스페이스를 지정합니다. -->
<mapper namespace="mapper.member">

<!-- SQL문을 실행한 후 반환되는 레코드들을 type 속성에서 지정한
     memberVO 빈에 저장합니다. -->  
<!-- 레코드의 칼럼 이름에 대해 memberVO의 같은 속성에 값도 설정합니다. -->

	<resultMap id="memResult" type="memberVO">

		<result property="id" column="id" />
        <result property="pwd" column="pwd" />
        <result property="name" column="name" />
        <result property="email" column="email" />
        <result property="joinDate" column="joinDate" />
	</resultMap>
	 
<!-- 이번에는 자바의 HashMap을 이용해 모든 회원을 죄회하는 기능을 실습해 보겠습니다.
     <resultMap> 태그의 type 속성에는 HashMap이 지정되어 있습니다.
         즉, SQL문 실행 시 레코드의 컬럼 이름을 key로 지정하고, 그 값을 value로 해서
     Hashmap에 차례대로 저장합니다. -->
<!-- 여기서, type="java.util.HashMap"의 의미는
         조회한 레코드를 지정한 컬럼 이름을 key, 값을 value로 해서 저장합니다.-->  
<!-- 
	<resultMap id="memResult" type="java.util.HashMap">
      <result property="id" column="id" />
      <result property="pwd" column="pwd" />
      <result property="name" column="name" />
      <result property="email" column="email" />
      <result property="joinDate" column="joinDate" />
   </resultMap>
 -->

	<!-- DAO에서 namespace.id를 이용해(즉, id="selectAllMemberList")
	         해당 SQL문을 호출합니다. -->
	<!-- resultMap="memResult"의 의미는 반환되는 레코드를
	     memResult에 저장합니다. -->
	<!-- 조회한 회원 정보를 Hashmap에 저장합니다. -->
	<select id="selectAllMemberList" resultMap="memResult">
      <!-- SQL문의 >, <, <=, >= 같은 연산자들을 XML 파일에서 작성하면
                    연산자가 아닌 특수 문자로 인식하므로 오류가 발생합니다.
                    이러한 연산자들도 SQL문의 일부라는 것을 알려주기 위해
           <![CDATA[ ... ]]> 태그 안에 작성해야 합니다.        -->
      <!-- 즉, CDATA Section(영역)은 Mybatis와는 상관없는
           XML 고유의 문법 영역으로서, CDATA 영역에 작성된 데이터는
                    단순한 문자 데이터(Character DATA)이므로  XML 파서가
                    해석하지 않도록 한다. 결국, CDATA Section(영역) 안에 작성된
                    데이터는 XML 파서가 처리하지 않고 데이터베이스에 그대로 전달하므로
                    문제가 발생하지 않는다. -->
      <![CDATA[
         select * from t_member	order by joinDate desc	 	
      ]]>
	</select>
	
	<!-- 조건 값으로 회원 정보 조회하기  -->
	<!-- 조건 값으로 조회하는 경우는 브라우저에서 전달 되는 값이 있으므로
	     select 태그에 parameterType 속성을 전달되는 조건 값의
	         데이터 타입으로 지정합니다. 조건 값이 문자열인 경우는 parameterType
	         속성을 String으로, 정수인 경우는 int로 설정합니다. -->
	<!-- 참고로, MemberDAO에서 메서드 호출 시 전달된 조건 값은 매개변수 이름으로
	     SQL문의 조건식에 #{전달된 매개변수이름} 형식으로 사용합니다.
	         그리고, 조회되는 레코드가 한 개인 경우는 resultType 속성에
	         레코드를 저장할 memberVO를 설정합니다.  -->

	<!-- id="selectMemberById"은 MemberDAO에서 호출하는 id를 지정합니다. -->
	<!-- resultType="memberVO"는 조회되는 한 개의 레코드를 memberVO에
	         저장합니다. -->
	<!-- parameterType="String"는 MemberDAO에서 SQL문 호출 시
	         전달되는 매개변수의 데이터 타입을 지정합니다. -->
	<!-- #{id}는 MemberDAO에서 메서드를 호출하면서 parameterType으로
	         전달된 매개변수 이름을 select문의 id 조건 값으로 사용합니다. -->
	<select id="selectMemberById" resultType="memberVO"
	parameterType="String">
	<![CDATA[
		SELECT * FROM T_MEMBER
		WHERE
		ID=#{id}	
	]]>	
	</select>  
	
	<!-- #{pwd}은 SQL문 실행 시 매개변수 이름을 pwd의 조건값으로 사용합니다. -->
	<select id="selectMemberByPwd" resultMap="memResult"
	parameterType="int">
	<![CDATA[
		SELECT * FROM T_MEMBER
		WHERE
		PWD=#{pwd}	
	]]>	
	</select>          

	<!-- 회원의 ID와 비밀번호 조회 : 즉, 테이블의 회원 정보 중 문자열이나
	         정수와 같은 기본형 데이터를 조회해 보겠습니다.
	         그러기 위해, member.xml에서 select 태그의 SQL문에 접근하기 위해
	     id를 설정합니다. resultType은 SQL문을 실행했을 때 한 개의 데이터를
	         조회하므로 String(문자열), int(정수)로 지정합니다. -->	
	<!-- MemberDAO에서 접근 시 사용할 SQL문의 id를 지정합니다.
	         여기서는 id="selectName" 을 지정했습니다. -->
	<!-- resultType="String"의 의미는 resultType 속성을 문자열로
	         지정해 SQL문으로 조회한 이름(문자열)을 호출한 메서드로 반환합니다. -->
	<select id="selectName" resultType="String">
    <![CDATA[
	select name from t_member
	where id = 'jangnara'			
    ]]>
	</select>
	
	<!-- MemberDAO에서 접근 시 사용할 SQL문의 id를 지정합니다.
	         여기서는 id="selectPwd" 을 지정했습니다. -->
	<!-- resultType="int"의 의미는 resultType 속성을 int형으로
	         지정해 SQL문으로 조회한 정수를 호출한 메서드로 반환합니다. -->
	<select id="selectPwd" resultType="int" >
	  <![CDATA[ 
	    select pwd from t_member 
	    where id = 'jangnara'
	 ]]>
	 </select> 
	 
	 <!-- parameterType="memberVO"는 MemberDAO에서 회원 정보를
	      memberVO의 속성에 저장해서 넘깁니다. -->
	 <!-- values(#{id}, #{pwd}, #{name}, #{email})는
	      memberVO의 속성 이름에 저장된 값을 value로 설정합니다. -->
	 <!-- 즉, insert문은 insert 태그를 이용해 작성하고
	           등록할 회원 정보를 memberVO 빈에 설정한 후 insert 태그의
	      parameterType의 memberVO로 전달합니다.
	      values 다음에 #{속성이름}을 나열하면 memberVO 빈의 속성 값이
	           설정됩니다. -->
     <insert id="insertMember"  parameterType="memberVO">
		<![CDATA[
		 insert into t_member(id,pwd, name, email)
		 values(#{id}, #{pwd}, #{name}, #{email})
		]]>      
	</insert>
	
	<insert id="insertMember2"  parameterType="java.util.Map">
		<![CDATA[
			 insert into t_member(id,pwd, name, email)
			 values(#{id}, #{pwd}, #{name}, #{email})
		]]>      
   </insert>
   
   <update id="updateMember"  parameterType="memberVO">
     <![CDATA[
	     update t_member
	     set pwd=#{pwd}, name=#{name}, email=#{email}
	     where
	     id=#{id}
      ]]>      
   </update> 
     
   <delete id="deleteMember"  parameterType="String">
	<![CDATA[
	   delete from  t_member
	   where
	   id=#{id}
	]]>      
  </delete>
	
	
	<!-- 동적 SQL문 -->
  <select id="searchMember" parameterType="memberVO" resultMap="memResult">
      <![CDATA[
          select * from t_member
      ]]>
      <where>
         <if test=" name != ''  and  name != null">
            name=#{name}
         </if>
         <if test="email != ''  and email != null ">
           and email = #{email}
         </if>
      </where>
      order by joinDate desc
  </select>
  
 <!--  
   <sql id="a">
    <![CDATA[
      select * from t_member
     ]]> 
   </sql>  -->  
  
<!--    
  <select id="searchMember" parameterType="memberVO" resultMap="memResult">
	     <include refid="a" /> 
	   <![CDATA[
         select * from t_member 
      ]]>
	  
       <where>
		  <choose>
		      <when test="name != '' and name != null and  email != '' and email != null">
			     name=#{name} and email=#{email}
		      </when>
		      <when test="name != '' and name != null">
			     name = #{name}
		      </when>
		      <when test="email !='' and email != null">
			    email = #{email}
		      </when>
	      </choose>
       </where>
       order by joinDate desc
   </select> -->
   
   <select id="foreachSelect" resultMap="memResult" parameterType="java.util.Map">
      <!-- <include refid="a" /> -->
      <![CDATA[
        select * from t_member 
          
      ]]>
      
      where name in
      <foreach item="item" collection="list" open="(" separator="," close=")" >
         #{item}
      </foreach>
      order by joinDate desc
   </select>
   
   <insert id="foreachInsert"  parameterType="java.util.Map">
      <foreach item="item"  collection="list"   open="INSERT ALL" separator=" " close="SELECT * FROM DUAL" >
          INTO  t_member(id, pwd, name, email)
          VALUES  (#{item.id},
                    #{item.pwd},
                    #{item.name},
                    #{item.email})
      </foreach>
   </insert>
   
   <!-- 
    <select id="selectLike" resultMap="memResult"  parameterType="String" >
      <![CDATA[
         select * from t_member
         where
         name like '%'#{name}'%'		
      ]]>
    </select>
     -->
   <!--  like 검색 -->
   <select id="selectLike" resultMap="memResult"  parameterType="String" >
      <![CDATA[
         select * from t_member
         where
         name like '%' || #{name} || '%'		
      ]]>
    </select>
</mapper>